# Общие

## Правила

### Именование классов

- Не используем *snakeCase* и *camelCase* в именовании классов. Только *kebab-case*.
([programming-case-types](https://techrocks.ru/2018/08/09/most-common-programming-case-types/))

- Называем классы семантически.

```html
Хорошо:
<div class=”tq-question”></div>

Плохо:
<div class=”tq-row”></div>
```

### Variables

- Переменные должны быть семантическими.

```scss
Хорошо:
$color-link: #fff;

Плохо:
$color-blue: #fff;
```

:exclamation: *допускается создание переменных для базовых цветов типа black, white с аналогичным названим ```$color-black, $color-white```*

- Переменные создаем только для основной палитры цветов.

- Создаём переменную только в том случае если возможно изменение цвета внутри переменной например: линк, кнопка. Если же цвет встречается единично, например бэкграунд у чекбокса, то проще написать #fff.

### Порядок написания

- При написании аттрибутов рекомендуется следовать принципу "от важных к менее важным"
Пример: [link](https://github.com/brandon-rhodes/Concentric-CSS/blob/master/style.css)


### Buttons

- Не использовать модификаторы без базового класса.
```html
Хорошо:
<div class=”btn btn-white btn-rounded”>Click Me!</div>
Плохо:
<div class=”btn-white btn-rounded”>Click Me!</div>
```
Написание без базового класса допустимо но является deprecated.

### @media запросы
- Используем @media-запросы внутри класса

### Файловая структура

- Не рекомендуется создавать файлы стилей для отдельных страниц. Предпочтение компонентному подходу.


### Общие компоненты

Правила разработаны с целью изолировать стили общих компонентов, чтобы снизить риски непредсказуемого поведения компонента в зависимости от разного окружения в котором он находится.

При работе с общими компонентами:
- Стили пишем внутри vue компонента **scoped** (доступны будут только внутри этого компонента)
- Не используем классы от конкретной эко-системы (админ/client/tq).
- Родительский класс (зависит от роли) компонента передается через пропсы и добавляется к корневому элементу.
- Классы должны быть семантичны, то есть имя класса должно говорить о роли самого элемента.

### Изоляция стилей

**Пример проблемы**: подключение TQ в область админки приводит к тому, что одинаковые классы из Beyonce и TQ пересекаются и переопределяют друг друга.

**Решение**: Именование классов (в данном случае TQ) должно начинаться с приставки имени проекта (.tq-input, .tq-icon)

### Разметка для тестов

**Проблема:**

В тестах возникают трудности с поиском кликабельных элементов (кнопок), которые написаны через div, span etc.

**Решение:**

Для ссылок используем тэг ```<a>```, для кнопок - ```<button>```

**Определение:**

```md
Используем ссылку <a> - Если при клике на элемент мы ожидаем перехода по странице
(изменения url, routers)

Если это кликабельный элемент и не ссылка - это кнопка <button>
```


## Хелперы

### Правила использования
Хелперы ([Утилитарные классы](https://frontstuff.io/in-defense-of-utility-first-css)) - вспомогательные функциональные классы, позволяющие быстро описывать или модифицировать элементы в разметке HTML, не создавая новых классов.

**Плюсы:**

- быстро создавать простые элементы или описывать существующие из готовых классов
- не загрязнять CSS бесполезными классами, к примеру несколько элементов можно описать хелперами не создавая лишние строки в стилях для их описания
- модифицировать любой компонент, расширяя его базовые возможности ``(пример - кнопка, которой мы добавляем отступ снизу + жирный шрифт .button.m-b-20.font-bold)``

:exclamation: Тем не менее, не рекомендуется злоупотреблять такими классами. Также, частота их использования зависит напрямую от области проекта.

В **Админке (Beyonce)** использование хелперов чаще приветствуется, т.к. однотипные блоки удобно собирать по типу конструктора, они часто похожи и отличаются лишь мелочами, которые могут поправить утилитарные классы.

В **TQ** и других областях проекта хелперы использовать не рекомендуется без очевидной причины т.к. проще поддерживать описанные компоненты, которые редко меняются.

**Минусы:**
- большое кол-во хелперов на элементе явно говорит о том, что их стоит собрать в один класс и описать компонент как отдельную сущность
- семантически элемент с навешенными на него классами-хелперами не дает никакой информации о предназначении самого компонента, его роли и принадлежности
- бывает ситуация, когда блок описан несколькими хелперами, а затем нужно добавить ему несколько свойств, которых нет в списке хелперов (добавить тень и фон), в таком случае все равно нужно именовать этот блок и добавлять к нему пару строк стилей и смысл от перечисленных в нем ранее хелперов пропадает, т.к можно все это перенести в класс блока
- если элемент имеет непростое описание в стилях (более 4х свойств) - не стоит создавать его с помощью хелперов, т.к. это очевидно отдельная сущность/компонент, который должен иметь семантический класс

**Вывод:**

Хелперы (утилитарные классы) полезно использовать, но только разобравшись с тем, что они действительно уместны.

Лучшее применение будет в следующей ситуации:
Есть готовый компонент, имеющий собственный класс (пример - кнопка .button), конкретно в этом случае нужно произвести небольшую модификацию этого компонента (изменить шрифт, добавить отступ, etc.). Дописывать класс модификатор для этого компонента ``button-[mod]`` не логично, т.к. мы раздуваем стили описывая модификацию, которая не должна встречаться достаточно часто. Лучший способ - дописать здесь модификатор. Таким образом, результат достигается быстро и не требуя изменений в файле стилей.


### Ширина в процентах

В некоторых случаях необходимо задать ширину двум блокам, к примеру, в рамках одного родителя с шириной 30% и 70% сответственно. Для того, чтобы не придумывать новых классов для элементов и просто указать их соотношение используются **width-30** и **width-70**.

Аналогичный класс с приставкой mobile- нужен для того, чтобы изменять ширину элемента только в мобильной версии. Такое часто бывает необходимо в случае, если в десктоп версии блок занимает 50%, но в мобайл должен быть 100%. Такой элемент будет иметь два класса ``class="width-50 mobile-width-100"``

```scss
Пример реализации в стилях:
@for $k from 0 through 100 {
  .width-#{$k} {
    width: #{$k}#{'%'};
  }
}

@media #{$mobile} {
  @for $i from 0 through 100 {
    .mobile-width-#{$i} {
      max-width: #{$i}#{'%'};
      width: 100%;
    }
  }
}
```
<br/>

### Отступы

Для простого добавления внутренних и внешних отступов можно использовать классы margin'a и padding'a с желаемым значением в пикселях.

Пример: внешний отступ слева и справа в 15пх, внутренний снизу 10пх - ``class="m-l-15 m-r-15 p-b-10"``

```scss
@for $m from 0 through 50 {
  .m {
    &-t-#{$m} {
      margin-top: #{$m}#{'px'};
    }

    &-r-#{$m} {
      margin-right: #{$m}#{'px'};
    }

    &-b-#{$m} {
      margin-bottom: #{$m}#{'px'};
    }

    &-l-#{$m} {
      margin-left: #{$m}#{'px'};
    }
  }

  .p {
    &-t-#{$m} {
      padding-top: #{$m}#{'px'};
    }

    &-r-#{$m} {
      padding-right: #{$m}#{'px'};
    }

    &-b-#{$m} {
      padding-bottom: #{$m}#{'px'};
    }

    &-l-#{$m} {
      padding-left: #{$m}#{'px'};
    }
  }
}
```
<br/>

### Flexible классы

```scss
// позволяет разместить дочерние блоки в один ряд без переноса на новую строку
.flex {
  display: flex;
}
// дочерние блоки отталкиваются по разным краям
.space-between {
  display: flex;
  justify-content: space-between;
}
// когда нужно расположить элемены в один ряд без переноса их на новую строку, идеально подходит для строки с несколькими инпутами.
.row {
  display: flex;
  flex-direction: row;
  margin-bottom: 15px;
  width: 100%;

  // row-wrap - это ряд который позволяет сбрасывать элементы на след.строку если места будет недостаточно.
  &-wrap {
    flex-flow: row wrap
  }
}

// все элементы внутри блока с этим классом будут начинаться с новой строки, полезно для формы с инпутами, где каждый блок который содержит в себе label+input будет занимать всю ширину и создавать отступ снизу
.column {
  display: flex;
  flex-direction: column;
  margin-bottom: 15px;
  width: 100%;
}

// выравнивание контента внутри блока
.content {
  &-left {
    display: flex;
    justify-content: flex-start;
    text-align: left;
  }

  &-right {
    display: flex;
    justify-content: flex-end;
    text-align: right;
  }

  &-bottom {
    display: flex;
    align-items: flex-end;
  }
}

// вертикальное выравнивание по центру
.v-center {
  display: flex;
  align-items: center;
}
// горизонтальное выравнивание по центру
.h-center {
  display: flex;
  justify-content: center;
}
// вертикальное и горизонтальное выравнивание по центру
.all-center {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

### Шрифт

```scss
.font {
  &-italic {
    font-style: italic;
  }

  &-bold {
    font-weight: bold;
  }

  &-normal {
    font-weight: normal;
  }
}
// размер шрифта можно задать элементу классом-хелпером со значением от 10 до 20 px
@for $s from 10 through 20 {
  .font-size-#{$s} {
    font-size: #{$s}#{'px'};
  }
}

// Не разрешать тексту сброс на новую строку
.no-break {
  flex-wrap: nowrap;
  word-break: keep-all;
  white-space: nowrap;
}

// Сбрасывать текст на новую строку, если места недостаточно
.break-all {
  flex-wrap: wrap;
  word-break: break-all;
  white-space: normal;
}

// Перенос по словам - сбрасывать текст на новую строку, но только в случае если есть пробел (ссылка переносится не будет)
.break-word {
  flex-wrap: wrap;
  word-break: break-word;
  white-space: normal;
}
```
